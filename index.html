<!DOCTYPE html>
<html>
  <head>
    <title>Colosseum LOS</title>
    <style>
      #map {
        border: 1px solid black;
        display: inline-block;
      }
      #tape {
        display: inline-block;
        vertical-align: top;
      }
      button {
        margin-bottom: 3px;
      }
      .south {
        -webkit-transform: rotate(180deg);
        -moz-transform: rotate(180deg);
        -ms-transform: rotate(180deg);
        -o-transform: rotate(180deg);
        transform: rotate(180deg);
      }
    </style>
  </head>
  <body id="container">
    <div style="margin-bottom: 10px; width: 756px; text-align: center">
      <button onclick="remove()">Clear</button>
      &nbsp;
      <button onclick="place()">Place NPC</button>
      &nbsp;
      <button onclick="setMode(0)">Player</button>
      &nbsp;
      <button onclick="setMode(1)">Serpent</button>
      &nbsp;
      <button onclick="setMode(2)">Javelin</button>
      &nbsp;
      <button onclick="setMode(3)">Jaguar</button>
      &nbsp;
      <button onclick="setMode(4, 'r')">Manticore (Range)</button>
      &nbsp;
      <button onclick="setMode(4, 'm')">Manticore (Mage)</button>
      &nbsp;
      <button onclick="setMode(5)">Minotaur</button>
      &nbsp;
      <button onclick="setMode(6)">Shockwave</button>
    </div>
    <div style="margin-bottom: 10px; width: 756px; text-align: center">
      (North is always top in this tool) &nbsp;&nbsp;&nbsp;Toggle: &nbsp;
      <!--<button onclick="toggleNS()">N/S</button>-->
      <button onclick="togglePlayerLoS()">LoS</button>
      <button onClick="copySpawnURL()">Copy Spawn URL</button>
      <button
        id="copyReplayUrlButton"
        disabled="true"
        onClick="copyReplayURL()"
        title="Select a segment of the tick diagram to export a replay (max 32 ticks)"
      >
        Copy Replay URL
      </button>
    </div>
    <div style="margin-bottom: 10px; width: 756px; text-align: center">
      <div id="replayIndicator"></div>
      Controls: &nbsp;
      <button
        onclick="reset(); drawWave();"
        title="hotkey: down or mousewheel down"
      >
        &laquo; Reset
      </button>
      &nbsp;
      <button
        onclick="toggleAutoReplay()"
        id="replayAutoButton"
        hidden="true"
      ></button>
      &nbsp;
      <button onclick="step(); drawWave();" title="hotkey: up or mousewheel up">
        Step &raquo;
      </button>
    </div>

    <canvas
      id="map"
      onselectstart="return false"
      oncontextmenu="return false"
      style=""
    ></canvas>
    <p style="font-size: 12px">
      Based on
      <a href="https://ifreedive-osrs.github.io/">ifreedive's tool</a> which is
      in turn based on some code from
      <a href="https://bistools.github.io/inferno.html">Backseat's tool</a>,
      adapted by
      <a href="https://github.com/Supalosa/osrs-colosseum">Supalosa</a> for
      Colosseum.
      <a href="https://github.com/Supalosa/osrs-colosseum/issues"
        >[Issue tracker]</a
      >
    </p>

    <script>
      var SIZE = [1, 1, 3, 2, 3, 3, 3];
      var RANGE = [10, 10, 15, 1, 15, 1, 15];
      var CD = [0, 5, 5, 5, 10, 5, 5];
      var img_sources = [
        "",
        "serpent_shaman.png", // 10 range
        "javelin_colossus.png", // 15 range
        "jaguar_warrior.png",
        "manticore.png",
        "minotaur.png",
        "shockwave_colossus.png",
      ];

      var colors = ["cyan", "cyan", "lime", "orange", "purple", "red", "blue"];

      var img_sources_north = img_sources;
      const MANTICORE = 4;
      const MANTICORE_RANGE_FIRST = "r";
      const MANTICORE_MAGE_FIRST = "m";
      const MANTICORE_ATTACKS = ["lime", "blue", "red"];
      const DEFAULT_MANTICORE_MODE = MANTICORE_RANGE_FIRST;
      const MANTICORE_PATTERNS = {
        [MANTICORE_RANGE_FIRST]: [0, 1, 2],
        [MANTICORE_MAGE_FIRST]: [1, 0, 2],
      };

      var pillars = [
        [8, 10],
        [23, 10],
        [8, 25],
        [23, 25],
      ];
      var filters = [true, true, true, true];
      var south = false;

      var spawns = [];

      // each entry represents the spans across the x axis for that a corresponding y value
      const blockedTileRanges = [
        [
          [0, 13],
          [15, 19], // door
          [21, 34],
        ],

        [
          [0, 9],
          [25, 34],
        ], // 1

        [
          [0, 7],
          [27, 34],
        ], // 2

        [
          [0, 6],
          [29, 34],
        ], // 3

        [
          [0, 5],
          [29, 34],
        ], // 4

        [
          [0, 4],
          [31, 34],
        ], // 5

        [
          [0, 3],
          [31, 34],
        ], // 6

        [
          [0, 2],
          [32, 34],
        ], // 7

        [
          [0, 2],
          [32, 34],
        ], // 8

        [
          [0, 1],
          [33, 34],
        ], // 9
        [
          [0, 1],
          [33, 34],
        ], // 10

        [
          [0, 1],
          [32, 34],
        ],
        [
          [0, 1],
          [31, 34],
        ],

        [[31, 34]],
        [[31, 34]],

        [
          [0, 1],
          [31, 34],
        ],
        [
          [0, 1],
          [31, 34],
        ],
        [
          [0, 1],
          [31, 34],
        ],
        [
          [0, 1],
          [31, 34],
        ],

        [[31, 34]],
        [[31, 34]],

        [
          [0, 1],
          [31, 34],
        ],
        [
          [0, 1],
          [32, 34],
        ],
        [
          [0, 1],
          [33, 34],
        ],
        [
          [0, 1],
          [33, 34],
        ],

        [
          [0, 2],
          [32, 34],
        ],
        [
          [0, 2],
          [32, 34],
        ],

        [
          [0, 3],
          [31, 34],
        ],
        [
          [0, 3],
          [31, 34],
        ],

        [
          [0, 5],
          [29, 34],
        ],
        [
          [0, 5],
          [29, 34],
        ],

        [
          [0, 7],
          [27, 34],
        ],

        [
          [0, 9],
          [25, 34],
        ],

        [
          [0, 13],
          [15, 19], // door
          [21, 34],
        ],
      ];

      var mode = 0;
      var modeExtra = null;
      var degen = false;
      var b5Tile = [5, 15];
      var selected = [...b5Tile];
      var mobs = [];
      var showSpawns = true;
      var showPlayerLoS = true;
      var showZukSpots = true;
      var checker = true;

      // tape for mobs
      var tape = [];
      var playerTape = [];
      // tape selection, [start, end
      var tapeSelectionRange = null;

      let replay = null;
      let replayTick = null;
      let replayAuto = null;

      function doAutoTick() {
        step();
        drawWave();
      }
      function toggleAutoReplay() {
        if (replayAuto) {
          clearTimeout(replayAuto);
          replayAuto = null;
          drawWave();
        } else {
          replayAuto = setTimeout(() => doAutoTick(), 600);
        }
      }

      const MAX_EXPORT_LENGTH = 128;

      let manticoreTicksRemaining = {};

      var can = document.getElementById("map");
      var ctx = can.getContext("2d");
      var size = 20;
      var map_width = 34;
      var map_height = 34;
      const TICKER_WIDTH = 9;
      const CANVAS_WIDTH = size * map_width + TICKER_WIDTH * size;
      const CANVAS_HEIGHT = size * map_height;
      can.width = CANVAS_WIDTH;
      can.height = CANVAS_HEIGHT;
      document.addEventListener("DOMContentLoaded", function () {
        var spawn = parent.location.search
          .replace("?", "")
          .split(".")
          .filter((s) => !!s);
        for (i = 0; i < spawn.length; i++) {
          if (spawn[i] === "degeN") {
            toggleNS();
          } else {
            var lx = parseInt(spawn[i].slice(0, 2));
            var ly = parseInt(spawn[i].slice(2, 4));
            var lm = parseInt(spawn[i].slice(4));
            var extra = spawn[i].slice(5) || null;
            mobs.push([lx, ly, lm, lx, ly, 0, extra]);
          }
        }
        var hash = parent.location.hash
          ?.replace("#", "")
          .split(".")
          .filter((s) => !!s);
        if (hash?.length > 0) {
          const decodeSection = (section) => {
            const split = section.split("x");
            const runLength = split.length > 1 ? parseInt(split[1]) : 1;
            const coordinate = decodeCoordinates(parseInt(split[0]));
            return Array(runLength).fill(coordinate);
          };
          replay = hash.flatMap((section) => decodeSection(section));
          replayTick = 0;
          selected = replay[0];
          replayAuto = setTimeout(() => doAutoTick(), 600);
        }
        drawWave();
      });
      document
        .getElementById("map")
        .addEventListener("mousedown", function (e) {
          var x = e.offsetX;
          var y = e.offsetY;
          var selecting = false;
          x = Math.floor(x / size);
          y = Math.floor(y / size);
          if (x < map_width) {
            if (replay) {
              stopReplay();
            }
            if (mobs.length == 0) {
              selected[0] = x;
              selected[1] = y;
              drawWave();
            } else {
              for (var i = 0; i < mobs.length; i++) {
                if (mobs[i][0] == x && mobs[i][1] == y) {
                  selecting = true;
                  drawWave();
                }
              }
            }
            if (!selecting) {
              selected[0] = x;
              selected[1] = y;
              drawWave();
            }
          } else if (x <= CANVAS_WIDTH && y >= 0 && y <= tape.length + 1) {
            const tapeIndex = Math.floor(y);
            tapeSelectionRange = [tapeIndex];
            drawWave();
          }
        });

      document.getElementById("map").addEventListener("mouseup", function (e) {
        var x = e.offsetX;
        var y = e.offsetY;
        x = Math.floor(x / size);
        y = Math.floor(y / size);
        if (tapeSelectionRange?.length === 1) {
          if (
            x >= map_width &&
            x <= CANVAS_WIDTH &&
            y >= 0 &&
            y <= CANVAS_HEIGHT
          ) {
            const endY = Math.min(y + 1, tape.length);
            tapeSelectionRange = [tapeSelectionRange[0], endY];
          }
          drawWave();
        }
      });
      document.getElementById("map").addEventListener("dblclick", function (e) {
        var x = e.offsetX;
        var y = e.offsetY;
        x = Math.floor(x / size);
        y = Math.floor(y / size);
        if (x < map_width) {
          for (var i = 0; i < mobs.length; i++) {
            if (mobs[i][0] == x && mobs[i][1] == y) {
              mobs.splice(i, 1);
            }
          }
          drawWave();
        }
      });
      document.getElementById("map").addEventListener("wheel", function (e) {
        if (e.deltaY > 0) {
          step();
          drawWave();
        } else {
          reset();
          drawWave();
        }
      });
      document.addEventListener("keydown", function (e) {
        switch (e.keyCode) {
          case 38:
            step();
            drawWave();
            break;
          case 40:
            reset();
            drawWave();
            break;
          case 81:
            mode = 1;
            place();
            drawWave();
            break;
          case 87:
            mode = 2;
            place();
            drawWave();
            break;
          case 69:
            mode = 5;
            place();
            drawWave();
            break;
          case 82:
            mode = 6;
            place();
            drawWave();
            break;
          case 84:
            mode = 7;
            place();
            drawWave();
            break;
          case 85:
            mode = 4;
            place();
            drawWave();
            break;
        }
      });
      document.addEventListener("keydown", function (e) {
        //keyboard shortcuts for future?
      });
      function getBaseUrl() {
        if (window.location.protocol === "file:") {
          return `${window.location.protocol}//${window.location.pathname}?`;
        }
        return `${window.location.protocol}//${window.location.host}/?`;
      }
      function getSpawnUrl(mobSpecs) {
        var url = getBaseUrl();
        mobSpecs.forEach(([locationX, locationY, mobType, extra]) => {
          url = url
            .concat(("00" + locationX).slice(-2))
            .concat(("00" + locationY).slice(-2))
            .concat(mobType);
          if (mobType === MANTICORE) {
            url = url.concat(extra);
          }
          url = url.concat(".");
        });
        if (degen) {
          url = url.concat(".degeN");
        }
        return url;
      }
      function copySpawnURL() {
        const mobSpecs = mobs
          .filter((mob) => mob[2] > 0)
          .map((mob) => [mob[0], mob[1], mob[2], mob[6]]);
        var url = getSpawnUrl(mobSpecs);
        copyQ(url);
        alert("Spawn URL Copied!");
      }
      function copyReplayURL() {
        if (tapeSelectionRange?.length != 2) {
          return;
        }
        const upperBound = Math.min(
          tapeSelectionRange[1],
          tapeSelectionRange[0] + MAX_EXPORT_LENGTH
        );
        var mobTicks = tape.slice(tapeSelectionRange[0], upperBound);
        var playerTicks = playerTape.slice(tapeSelectionRange[0], upperBound);

        const mobSpecs = mobTicks[0].map((tape, mobIdx) => [
          (tape >> 16) & 0xff,
          (tape >> 24) & 0xff,
          mobs[mobIdx][2],
          mobs[mobIdx][6],
        ]);
        var url = getSpawnUrl(mobSpecs);
        url = url.concat("#");
        var playerLocations = playerTicks.map(encodeCoordinate);
        // run-length encoding
        var last = playerLocations[0];
        var runLength = 1;
        for (var i = 1; i < playerLocations.length; i++) {
          if (playerLocations[i] !== last) {
            url = url.concat(last);
            if (runLength > 1) {
              url = url.concat(`x${runLength}`);
            }
            url = url.concat(`.`);
            runLength = 1;
          } else {
            runLength++;
          }
          last = playerLocations[i - 1];
        }
        url = url.concat(last);
        if (runLength > 1) {
          url = url.concat(`x${runLength}`);
        }

        copyQ(url);
        alert("Replay URL Copied!");
      }
      function encodeCoordinate(coords) {
        return (coords[0] & 0xff) | ((coords[1] & 0xff) << 8);
      }
      function decodeCoordinates(coords) {
        return [coords & 0xff, (coords >> 8) & 0xff];
      }
      function toggleSpawns() {
        showSpawns = !showSpawns;
        drawWave();
      }
      function togglePlayerLoS() {
        showPlayerLoS = !showPlayerLoS;
        drawWave();
      }
      function toggleZukSpots() {
        showZukSpots = !showZukSpots;
        drawWave();
      }
      function toggleNS() {
        document.getElementById("map").classList.toggle("south");
        degen = !degen;
        drawWave();
      }
      function toggleChecker() {
        checker = !checker;
        drawWave();
      }
      function isPillar(x, y) {
        var isPillar = false;
        for (var j = 0; j < pillars.length; j++) {
          if (filters[j]) {
            isPillar =
              doesCollide(x, y, 1, pillars[j][0], pillars[j][1], 3) || isPillar;
          }
        }
        /*
        if (y >= 0 && y < blockedTileRanges.length) {
          const ranges = blockedTileRanges[y];
          for (var j = 0; j < ranges.length; ++j) {
            const range = ranges[j];
            if (x >= range[0] && x < range[1]) {
              return true;
            }
          }
        }*/
        return isPillar;
      }
      function hasLOS(x1, y1, x2, y2, s = 1, r = 1, isNPC = false) {
        let dx = x2 - x1;
        let dy = y2 - y1;
        if (
          isPillar(x1, y1) ||
          isPillar(x2, y2) ||
          doesCollide(x1, y1, s, x2, y2, 1)
        ) {
          return false;
        }
        //assume range 1 is melee
        if (r == 1) {
          return (
            (dx < s && dx >= 0 && (dy == 1 || dy == -s)) ||
            (dy > -s && dy <= 0 && (dx == -1 || dx == s))
          );
        }
        if (isNPC) {
          var tx = Math.max(x1, Math.min(x1 + s - 1, x2));
          var ty = Math.max(y1 - s + 1, Math.min(y1, y2));
          return hasLOS(x2, y2, tx, ty, 1, r, false);
        }
        let dxAbs = Math.abs(dx);
        let dyAbs = Math.abs(dy);
        if (dxAbs > r || dyAbs > r) {
          return false;
        } //iFreedive
        if (dxAbs > dyAbs) {
          let xTile = x1;
          let y = (y1 << 16) + 0x8000;
          let slope = Math.trunc((dy << 16) / dxAbs); // Integer division
          let xInc = dx > 0 ? 1 : -1;
          if (dy < 0) {
            y -= 1; // For correct rounding
          }
          while (xTile !== x2) {
            xTile += xInc;
            let yTile = y >>> 16;
            if (isPillar(xTile, yTile)) {
              return false;
            }
            y += slope;
            let newYTile = y >>> 16;
            if (newYTile !== yTile && isPillar(xTile, newYTile)) {
              return false;
            }
          }
        } else {
          let yTile = y1;
          let x = (x1 << 16) + 0x8000;
          let slope = Math.trunc((dx << 16) / dyAbs); // Integer division
          let yInc = dy > 0 ? 1 : -1;
          if (dx < 0) {
            x -= 1; // For correct rounding
          }
          while (yTile !== y2) {
            yTile += yInc;
            let xTile = x >>> 16;
            if (isPillar(xTile, yTile)) {
              return false;
            }
            x += slope;
            let newXTile = x >>> 16;
            if (newXTile !== xTile && isPillar(newXTile, yTile)) {
              return false;
            }
          }
        }
        return true;
      }
      function doesCollide(x, y, s, x2, y2, s2) {
        if (
          x > x2 + s2 - 1 ||
          x + s - 1 < x2 ||
          y - s + 1 > y2 ||
          y < y2 - s2 + 1
        ) {
          return false;
        }
        return true;
      }
      function legalPosition(x, y, s, index) {
        var t = mobs[index][2];

        if (y - (s - 1) < 0 || x + (s - 1) > 28) {
          return false;
        }
        var collision = false;
        for (var i = 0; i < pillars.length; i++) {
          if (filters[i]) {
            collision =
              collision | doesCollide(x, y, s, pillars[i][0], pillars[i][1], 3);
          }
        }
        for (var i = 0; i < mobs.length; i++) {
          if (mobs[i][2] < 8) {
            if (i != index) {
              collision =
                collision |
                doesCollide(x, y, s, mobs[i][0], mobs[i][1], SIZE[mobs[i][2]]);
            }
          }
        }
        return !collision;
      }
      function digPosition(x, y) {
        if (y - 3 < 0 || x + 3 > 28 || x < 0 || y > 29) {
          return false;
        }
        var collision = false;
        for (var i = 0; i < pillars.length; i++) {
          if (filters[i]) {
            collision =
              collision | doesCollide(x, y, 4, pillars[i][0], pillars[i][1], 3);
          }
        }
        return !collision;
      }
      function place() {
        if (mode > 0) {
          //x y mode ox oy cooldown extra
          //prevent 2 mobs on same tile
          for (var i = 0; i < mobs.length; i++) {
            if (mobs[i][3] == selected[0] && mobs[i][4] == selected[1]) {
              return;
            }
          }
          mobs.push([
            selected[0],
            selected[1],
            mode,
            selected[0],
            selected[1],
            0,
            modeExtra,
          ]);
          mobs.sort(function (a, b) {
            return b[2] - a[2];
          });
        }
        mode = 0;
        modeExtra = null;
        drawWave();
      }
      function step() {
        if (replay && replay[replayTick]) {
          selected = replay[replayTick];
          replayTick = replayTick + 1;
          if (replayTick >= replay.length) {
            reset();
            replayTick = 0;
          }
          if (replayAuto) {
            clearTimeout(replayAuto);
            replayAuto = setTimeout(() => doAutoTick(), 600);
          }
        }
        if (mode == 0 && mobs.length > 0) {
          var line = [];
          for (var i = 0; i < mobs.length; i++) {
            if (mobs[i][2] < 8) {
              var mob = mobs[i];
              mob[5]--;
              var x = mob[0];
              var y = mob[1];
              var t = mob[2];
              var s = SIZE[t];
              var r = RANGE[t];
              var attacked = false;
              //move
              if (!hasLOS(x, y, selected[0], selected[1], s, r, true)) {
                var dx = x + Math.sign(selected[0] - x);
                var dy = y + Math.sign(selected[1] - y);
                //allows corner safespotting
                if (doesCollide(dx, dy, s, selected[0], selected[1], 1)) {
                  dy = mob[1];
                }
                if (legalPosition(dx, dy, s, i)) {
                  mob[0] = dx;
                  mob[1] = dy;
                } else if (legalPosition(dx, y, s, i)) {
                  mob[0] = dx;
                } else if (legalPosition(x, dy, s, i)) {
                  mob[1] = dy;
                }
              }
              x = mob[0];
              y = mob[1];
              //attack
              if (hasLOS(x, y, selected[0], selected[1], s, r, true)) {
                if (mob[5] <= 0) {
                  if (mob[2] === MANTICORE) {
                    manticoreTicksRemaining[i] = 3;
                  }
                  attacked = true;
                  mob[5] = CD[t];
                }
              }
              // pack the positions into 3rd and 4th byte (2nd byte is manticore attack style)
              const value = attacked | ((x & 0xff) << 16) | ((y & 0xff) << 24);
              line.push(value);
            }
          }
          Object.entries(manticoreTicksRemaining).forEach(([index, ticks]) => {
            if (ticks > 0 && mobs[index]) {
              const manticoreMode = mobs[index][6] || DEFAULT_MANTICORE_MODE;
              const manticoreStyles = MANTICORE_PATTERNS[manticoreMode];
              const currentStyle = manticoreStyles[3 - ticks];
              line[index] = true | (currentStyle << 8);
              manticoreTicksRemaining[index] = ticks - 1;
            } else {
              delete manticoreTicksRemaining[index];
            }
          });
          playerTape.push([selected[0], selected[1]]);
          tape.push(line);
        }
      }
      function stopReplay() {
        replay = null;
        replayTick = null;
      }
      function remove() {
        mobs = [];
        stopReplay();
        const url = new URL(window.location);
        url.search = "";
        url.hash = "";
        window.location = url.toString();
        reset();
        drawWave();
      }
      function reset() {
        for (var i = 0; i < mobs.length; i++) {
          mobs[i][0] = mobs[i][3];
          mobs[i][1] = mobs[i][4];
          mobs[i][5] = 0;
        }
        manticoreTicksRemaining = {};
        tape = [];
        playerTape = [];
        tapeSelectionRange = null;
        if (replay) {
          replayTick = 0;
          selected = replay[0];
        }
      }
      function setMode(m, extra) {
        mode = m;
        modeExtra = extra;
        drawWave();
      }
      function drawLOS(x, y, s, r, isNPC, color = "red") {
        if (showPlayerLoS) {
          ctx.globalAlpha = 0.2;
        } else {
          ctx.globalAlpha = 0;
        }

        for (var i = 0; i < map_width * map_height; i++) {
          ctx.fillStyle = color;

          var x2 = i % map_width;
          var y2 = Math.floor(i / map_height);

          if (hasLOS(x, y, x2, y2, s, r, isNPC)) {
            ctx.fillRect(x2 * size, y2 * size, size, size);
          }
        }
        ctx.globalAlpha = 1;
      }
      function updateUi() {
        if (replayAuto) {
          replayAutoButton.innerHTML = "Pause";
        } else {
          replayAutoButton.innerHTML = "Play";
        }
        if (replay && replay[replayTick]) {
          replayAutoButton.hidden = false;
        } else {
          replayAutoButton.hidden = true;
        }
        copyReplayUrlButton.disabled = tapeSelectionRange?.length != 2;
        replayIndicator.innerHTML = !!replay
          ? `<strong><span style="color: #FF0000;">Replay: Tick ${
              replayTick + 1
            } / ${replay.length}</span></strong>`
          : null;
      }
      function drawWave() {
        updateUi();
        ctx.globalAlpha = 1;
        ctx.clearRect(0, 0, can.width, can.height);

        const scale = (p) => p * size;
        function drawManticorePattern(pattern, x, y) {
          pattern.forEach((colorIndex, index) => {
            const color = MANTICORE_ATTACKS[colorIndex];
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(
              scale(x + 2.5),
              scale(y - index + 0.5),
              size / 2,
              0,
              Math.PI * 2
            );
            ctx.fill();
          });
        }

        if (checker == true) {
          checkerColor = "#eee";
        } else {
          checkerColor = "#fff";
        }
        for (var i = 0; i < map_width * map_height; i++) {
          const x = i % map_width;
          const y = Math.floor(i / map_width);
          ctx.fillStyle = (i + (y % 2)) % 2 ? "#fff" : checkerColor;
          ctx.fillRect(x * size, y * size, size, size);
        }
        // colosseum border
        ctx.fillStyle = "#000";
        blockedTileRanges.forEach((ranges, y) => {
          ranges.forEach((range) => {
            ctx.fillRect(
              scale(range[0]),
              scale(y),
              scale(range[1] - range[0]),
              scale(1)
            );
          });
        });

        //pillars
        ctx.fillStyle = "#222";
        for (var i = 0; i < pillars.length; i++) {
          if (filters[i]) {
            ctx.fillRect(
              pillars[i][0] * size,
              (pillars[i][1] + 1) * size,
              3 * size,
              -3 * size
            );
          }
        }
        if (showSpawns) {
          ctx.globalAlpha = 0.35;
        } else {
          ctx.globalAlpha = 0;
        }
        ctx.fillStyle = "#999";
        for (var i = 0; i < spawns.length; i++) {
          ctx.fillRect(
            spawns[i][0] * size,
            (spawns[i][1] + 1) * size,
            4 * size,
            -4 * size
          );
        }
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#9F9";
        ctx.fillRect(scale(b5Tile[0]), scale(b5Tile[1]), size, size);
        ctx.globalAlpha = 1;
        //mobs
        for (var i = 0; i < mobs.length; i++) {
          var x = mobs[i][0];
          var y = mobs[i][1];
          const t = mobs[i][2];
          var s = SIZE[t];
          var r = RANGE[t];
          var c = colors[t];
          ctx.fillStyle = ctx.strokeStyle = c;
          if (t < 8) {
            ctx.fillRect(
              mobs[i][0] * size,
              (mobs[i][1] + 1) * size,
              1 * size,
              -1 * size
            );
            ctx.strokeRect(
              mobs[i][0] * size + 1,
              (mobs[i][1] + 1) * size - 1,
              s * size,
              -s * size
            );
          }
          if (
            mode == 0 &&
            hasLOS(mobs[i][0], mobs[i][1], selected[0], selected[1], s, r, true)
          ) {
            ctx.fillStyle = "black";
            ctx.fillRect(
              mobs[i][0] * size,
              (mobs[i][1] + 1) * size,
              (1 * size) / 4,
              (-1 * size) / 4
            );
          }
        }
        var s = SIZE[mode];
        var r = RANGE[mode];
        var c = colors[mode];
        drawLOS(selected[0], selected[1], s, r, mode > 0);
        ctx.fillStyle = ctx.strokeStyle = c;
        if (mode < 8) {
          ctx.fillRect(
            selected[0] * size,
            (selected[1] + 1) * size,
            1 * size,
            -1 * size
          );
          ctx.strokeRect(
            selected[0] * size,
            (selected[1] + 1) * size,
            s * size,
            -s * size
          );
        }
        var current_i = new Image();
        if (mode > 0) {
          if (document.getElementById("map").classList.contains("south")) {
            current_i.src = img_sources[mode];
          } else {
            current_i.src = img_sources_north[mode];
          }
          ctx.drawImage(
            current_i,
            selected[0] * size,
            (selected[1] - s + 1) * size,
            SIZE[mode] * size,
            SIZE[mode] * size
          );
        }
        if (mode === MANTICORE && modeExtra) {
          const colorPattern = MANTICORE_PATTERNS[modeExtra];
          drawManticorePattern(colorPattern, selected[0], selected[1]);
        }
        // ticker tape
        var offset = map_width * size;
        const tickerStartY = (idx) => size * idx;
        for (var i = 0; i < tape.length; i++) {
          ctx.fillStyle = i % 2 == 0 ? "#ddd" : "#eee";
          ctx.fillRect(offset, size * i, size * TICKER_WIDTH, size);
          for (var j = 0; j < tape[i].length; j++) {
            const value = tape[i][j];
            var attacked = value & 0xff;
            var t = mobs[j][2];
            if (t > 0 && attacked) {
              ctx.fillStyle = colors[t];
              ctx.fillRect(offset + size * j, tickerStartY(i), size, size);
            }
            if (attacked && t === MANTICORE) {
              const pattern = (value >> 8) & 0xff;
              ctx.fillStyle = MANTICORE_ATTACKS[pattern];
              ctx.beginPath();
              ctx.arc(
                offset + size * (j + 0.5),
                size * (i + 0.5),
                size / 2,
                0,
                Math.PI * 2
              );
              ctx.fill();
              ctx.strokeStyle = "white";
              ctx.stroke();
            }
          }
        }
        // ticker tape selection
        if (tapeSelectionRange?.length) {
          ctx.fillStyle = "yellow";
          ctx.globalAlpha = 0.25;
          const tapeStartY = tapeSelectionRange[0];
          const tapeEndY =
            tapeSelectionRange.length >= 2
              ? tapeSelectionRange[1]
              : tapeStartY + 1;
          ctx.fillRect(
            offset,
            tickerStartY(tapeStartY),
            size * TICKER_WIDTH,
            (tapeEndY - tapeStartY) * size
          );
          ctx.globalAlpha = 1;
        }
        // mobs
        for (var i = 0; i < mobs.length; i++) {
          const t = mobs[i][2];
          if (!t) {
            // player
            continue;
          }
          var mob_i = new Image();
          if (document.getElementById("map").classList.contains("south")) {
            mob_i.src = img_sources[t];
          } else {
            mob_i.src = img_sources_north[t];
          }
          ctx.drawImage(
            mob_i,
            mobs[i][0] * size,
            (mobs[i][1] - SIZE[mobs[i][2]] + 1) * size,
            SIZE[mobs[i][2]] * size,
            SIZE[mobs[i][2]] * size
          );
          if (t === MANTICORE) {
            const mobExtra = mobs[i][6];
            const colorPattern = MANTICORE_PATTERNS[mobExtra];
            drawManticorePattern(colorPattern, mobs[i][0], mobs[i][1]);
          }
        }
      }
      function copyQ(val) {
        var container = document.getElementById("container");
        var inp = document.createElement("input");
        inp.type = "text";
        container.appendChild(inp);
        inp.value = val;
        inp.select();
        document.execCommand("Copy");
        container.removeChild(container.lastChild);
      }
    </script>
  </body>
</html>
